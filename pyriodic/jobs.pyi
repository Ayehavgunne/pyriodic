from collections import deque
from datetime import datetime
from threading import Thread
from typing import Union
from typing import List
from typing import Tuple
from typing import Callable
from typing import Any
from pyriodic import Scheduler

WhenType = Union[str, datetime]


# noinspection PyMethodMayBeStatic,PyPropertyDefinition
class Job:
	def __init__(self, func: Callable, when: WhenType, name: str=None, repeating: bool=True, threaded: bool=True,
			ignore_exceptions: bool=False, retrys: int=0, retry_time: int=0, alt_func: Callable=None) -> None:
		self.when = when # type: WhenType
		self.retrys = retrys # type: int
		self.retry_time = retry_time # type: int
		self.name = name # type: str
		self.func = None # type: Callable[..., Any]
		self.alt_func = None # type: Callable[..., Any]
		self.ignore_exceptions = ignore_exceptions
		self.run_time_history = [] # type: List[datetime]
		self.status = 'waiting' # type: str
		self.thread = None # type: Thread
		self.parent = None # type: Scheduler
		self.exceptions = [] # type: List[Tuple[Exception, int]]

	@property
	def first_run_time(self) -> datetime: ...
	@property
	def last_run_time(self) -> datetime: ...
	def _add_run_time(self, dt: datetime) ->None: ...
	@property
	def run_count(self) -> int: ...
	def start(self) -> None: ...
	def is_waiting(self) -> bool: ...
	def wait(self) -> None: ...
	def pause(self) -> None: ...
	def is_paused(self) -> bool: ...
	def run(self, retrys: int=0, alt: bool=False) -> Thread: ...
	def is_running(self) -> bool: ...
	@staticmethod
	def is_in_future(when: datetime) -> bool: ...
	def __repr__(self) ->str: ...


# noinspection PyMethodMayBeStatic,PyPropertyDefinition
class DurationJob:
	def __init__(self, func: Callable, when: str, *argums: tuple, start_time: WhenType=None, name: str=None,
			repeating: bool=True, threaded: bool=True, ignore_exceptions: bool=False, retrys: int=0,
			retry_time: int=0, alt_func: Callable=None, **keyargs: dict) -> None:
		self.time_initialized = None # type: datetime
		self.when = when # type: WhenType
		self.start_time = start_time # type: WhenType

	@property
	def next_run_time(self) -> datetime: ...
	@property
	def first_run_time(self) -> datetime: ...
	@property
	def last_run_time(self) -> datetime: ...
	def _add_run_time(self, dt: datetime) ->None: ...
	@property
	def run_count(self) -> int: ...
	def start(self) -> None: ...
	def is_waiting(self) -> bool: ...
	def wait(self) -> None: ...
	def pause(self) -> None: ...
	def is_paused(self) -> bool: ...
	def run(self, retrys: int=0, alt: bool=False) -> Thread: ...
	def is_running(self) -> bool: ...
	@staticmethod
	def is_in_future(when: datetime) -> bool: ...
	def __repr__(self) ->str: ...


# noinspection PyMethodMayBeStatic,PyPropertyDefinition
class DatetimeJob:
	def __init__(self, func: Callable, when: WhenType, *argums: tuple, interval: str=None, name: str=None,
			repeating: bool=True, threaded: bool=True, ignore_exceptions: bool=False, retrys: int=0,
			retry_time: int=0, alt_func: Callable=None, custom_format: str=None, **keyargs: dict) -> None:
		self.interval = interval # type: str
		self.custom_format = custom_format # type: str
		self.when = when # type: WhenType

	@property
	def next_run_time(self) -> datetime: ...
	def increment(self, when: datetime) -> datetime: ...
	@property
	def first_run_time(self) -> datetime: ...
	@property
	def last_run_time(self) -> datetime: ...
	def _add_run_time(self, dt: datetime) ->None: ...
	@property
	def run_count(self) -> int: ...
	def start(self) -> None: ...
	def is_waiting(self) -> bool: ...
	def wait(self) -> None: ...
	def pause(self) -> None: ...
	def is_paused(self) -> bool: ...
	def run(self, retrys: int=0, alt: bool=False) -> Thread: ...
	def is_running(self) -> bool: ...
	@staticmethod
	def is_in_future(when: datetime) -> bool: ...
	def __repr__(self) ->str: ...


# noinspection PyMethodMayBeStatic,PyPropertyDefinition
class DatetimesJob:
	def __init__(self, func: Callable, when: str, interval: str, *argums: tuple, name: str=None,
			repeating: bool=True, threaded: bool=True, ignore_exceptions: bool=False, retrys: int=0,
			retry_time: int=0, alt_func: Callable=None, custom_format: str=None, **keyargs: dict) -> None:
	    self.queue = None #type: deque

	@property
	def next_run_time(self) -> datetime: ...
	def increment(self, when: datetime) -> datetime: ...
	@property
	def first_run_time(self) -> datetime: ...
	@property
	def last_run_time(self) -> datetime: ...
	def _add_run_time(self, dt: datetime) ->None: ...
	@property
	def run_count(self) -> int: ...
	def start(self) -> None: ...
	def is_waiting(self) -> bool: ...
	def wait(self) -> None: ...
	def pause(self) -> None: ...
	def is_paused(self) -> bool: ...
	def run(self, retrys: int=0, alt: bool=False) -> Thread: ...
	def is_running(self) -> bool: ...
	@staticmethod
	def is_in_future(when: datetime) -> bool: ...
	def __repr__(self) ->str: ...
