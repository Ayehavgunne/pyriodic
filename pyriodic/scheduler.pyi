from logging import Logger
from threading import Timer
from typing import Union
from typing import Dict
from typing import List
from typing import Callable
from datetime import datetime
from pyriodic import DurationJob
from pyriodic import DatetimeJob
from pyriodic import DatetimesJob

JobType = Union[DurationJob, DatetimeJob, DatetimesJob]
WhenType = Union[str, datetime]

# noinspection PyMethodMayBeStatic
class Scheduler:
	def __init__(self, log: Logger=None) -> None:
		self.jobs = [] # type: List[JobType]
		self.current_job = None # type: JobType
		self.sleeper = None # type: Timer
		self.running = False # type: bool

	def _set_timer(self) -> None: ...
	def _execute_job(self) -> None: ...
	def _sort_jobs(self) -> None: ...
	def _trim_jobs(self) -> None: ...
	def add_job(self, job: JobType) -> str: ...
	def schedule_job(self, job_type: Callable[..., JobType], when: WhenType, args: tuple=None, kwargs: dict=None,
			name: str=None, repeating: bool=True, threaded: bool=True, ignore_exceptions: bool=False, retrys: int=0,
			retry_time: int=0, alt_func: Callable=None, start_time: str=None, interval: str=None,
			custom_format: str=None) -> Callable: ...
	def get_job(self, name: str) -> JobType: ...
	def reset(self) -> None: ...
	def remove(self, name: str) -> None: ...
	def pop(self, name: str) -> JobType: ...
	def job_names(self) -> List[str]: ...
	def find_job_index(self, name: str) -> int: ...
	def next_run_times(self) -> Dict[str, datetime]: ...
	def start_all(self) -> None: ...
	def stop_scheduler(self) -> None: ...
	def pause_all(self, cancel_current: bool=False) -> None: ...
	def start_web_server(self, pre_existing_server: bool=False, port: int=8765) -> None: ...

def job_func_wrapper(job: JobType, log: Logger, retrys: int, alt: bool=False) -> None: ...
